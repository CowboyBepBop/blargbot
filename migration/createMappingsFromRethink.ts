import 'module-alias/register';

import config from '@config';
import { createLogger, Logger } from '@core/Logger';
import { TypeMapping } from '@core/types';
import { mapping as _mapping } from '@core/utils';
import fs from 'fs/promises';
import path from 'path';
import * as r from 'rethinkdb';

import { mapEvents } from './events.mapping';
import { mapGuild } from './guild.mapping';
import { mapLogs } from './logs.mapping';
import { mapSnippet } from './snippet.mapping';
import { mapStats } from './stats.mapping';
import { mapTag } from './tag.mapping';
import { mapUser } from './user.mapping';
import { mapVars } from './vars.mapping';

const mapping = _mapping;
mapping.array;

const currentMappings: Partial<Record<string, TypeMapping<unknown>>> = {
    events: mapEvents,
    guild: mapGuild,
    logs: mapLogs,
    snippet: mapSnippet,
    stats: mapStats,
    tag: mapTag,
    user: mapUser,
    vars: mapVars
};

void (async function () {
    const logger = createLogger(config, 'MAPFAC');
    const [rethink] = await Promise.all([
        r.connect({
            ...config.rethink,
            timeout: 10000
        })
    ]);

    const tables = await r.db(config.rethink.db).tableList().run(rethink);
    logger.info('Found tables', tables);
    for (const table of tables) {
        logger.info('Getting data from table', table);
        const source = await r.table(table).run(rethink);
        const data = await toArrayAsync(cursorToAsyncIterable(source, logger, table));
        const currentMapping = currentMappings[table];
        if (currentMapping !== undefined) {
            const failedRecords = data.filter(r => !currentMapping(r).valid);
            if (failedRecords.length === 0) {
                logger.info('Mapping for', table, 'is already sufficient, skipping.');
                continue;
            } else {
                logger.error('Mapping for', table, 'is insufficient for', failedRecords.length, 'records. Regenerating mapping.');
            }
        } else {
            logger.info('No mapping found for', table, ', generating.');
        }
        const mappingJs = [...createMappingJs(data)].join('\n');
        const outFile = path.join(__dirname, `/${table}.mapping.ts`);
        const tableTitle = `${table[0].toUpperCase()}${table.slice(1)}`;
        await fs.writeFile(outFile, `/* Autogenerated mapping by ${__filename} */

import { mapping } from '@core/utils';

export type OldRethink${tableTitle} = Extract<ReturnType<typeof map${tableTitle}>, { valid: true; }>['value'];
export const map${tableTitle} = ${mappingJs};
`
        );
        logger.info('Written auto-generated mapping to', path.resolve(outFile));

        const mapRecord = eval(mappingJs) as TypeMapping<unknown>;
        const failedRecords = data.filter(r => !mapRecord(r).valid);
        if (failedRecords.length > 0)
            logger.error(failedRecords.length, 'records failed auto-generated mapping');
    }
    logger.info('Mapping generation complete!');
    process.exit();
})();

function* createMappingJs(examples: Iterable<unknown>): Iterable<string> {
    const types = new Map<string, unknown[]>();
    for (const example of examples) {
        const type = example === null ? 'null'
            : example instanceof Date ? 'date'
                : Array.isArray(example) ? 'array'
                    : typeof example;
        const examples = types.get(type) ?? [];
        if (examples.length === 0)
            types.set(type, examples);
        examples.push(example);
    }
    const mappings = [];
    let allowUndefined = false;
    let allowNull = false;
    for (const [type, examples] of types) {
        switch (type) {
            case 'bigint':
                mappings.push(['mapping.bigint']);
                break;
            case 'boolean':
                mappings.push(['mapping.boolean']);
                break;
            case 'function':
                mappings.push(['mapping.fail']);
                break;
            case 'null':
                allowNull = true;
                break;
            case 'number':
                mappings.push(['mapping.number']);
                break;
            case 'object':
                mappings.push([...createObjectMappingJs(examples as Array<Record<PropertyKey, unknown>>)]);
                break;
            case 'date':
                mappings.push(['mapping.date']);
                break;
            case 'array': {
                const lines = [...createMappingJs(examples.flat())];
                if (lines.length === 1) {
                    mappings.push([`mapping.array(${lines[0]})`]);
                } else {
                    mappings.push([
                        `mapping.array(${lines[0]}`,
                        ...lines.slice(1, -1),
                        `${lines[lines.length - 1]})`
                    ]);
                }
                break;
            }
            case 'string':
                mappings.push(['mapping.string']);
                break;
            case 'symbol':
                mappings.push(['mapping.fail']);
                break;
            case 'undefined':
                allowUndefined = true;
                break;
        }
    }
    const postfix = allowUndefined
        ? allowNull ? '.nullish' : '.optional'
        : allowNull ? '.nullable' : '';

    if (mappings.length === 0) {
        if (allowUndefined && allowNull)
            yield 'mapping.in(null, undefined)';
        else if (allowUndefined)
            yield 'mapping.in(undefined)';
        else if (allowNull)
            yield 'mapping.in(null)';
        else
            yield 'mapping.in()';
    } else if (mappings.length === 1) {
        yield* mappings[0].slice(0, -1);
        yield `${mappings[0].slice(-1)[0]}${postfix}`;
    } else {
        yield 'mapping.choice(';
        for (const mapping of mappings.slice(0, -1)) {
            yield* mapping.slice(0, -1).map(m => `    ${m}`);
            yield `    ${mapping.slice(-1)[0]},`;
        }
        yield* mappings.slice(-1)[0].map(m => `    ${m}`);
        yield `)${postfix}`;
    }
}

function* createObjectMappingJs(examples: Iterable<Record<PropertyKey, unknown>>): Iterable<string> {
    const properties = new Map<string, unknown[]>();
    let total = 0;
    for (const example of examples) {
        total++;
        for (const [key, value] of Object.entries(example)) {
            const examples = properties.get(key) ?? [];
            if (examples.length === 0)
                properties.set(key, examples);
            examples.push(value);
        }
    }
    if (properties.size === 0) {
        yield 'mapping.object({})';
        return;
    }

    if (properties.size > 100 || [...properties.keys()].some(p => /^\d+$/.test(p)) || [...properties.keys()].every(p => p.length <= 1)) {
        const lines = [...createMappingJs([...properties.values()].flat())];
        if (lines.length === 1) {
            yield `mapping.record(${lines[0]}.optional)`;
        } else {
            yield `mapping.record(${lines[0]}`;
            yield* lines.slice(1, -1);
            yield `${lines[lines.length - 1]}.optional)`;
        }
        return;
    }

    const propertyMappings = [];
    for (const [propRaw, examples] of properties) {
        const prop = JSON.stringify(propRaw).slice(1, -1);
        if (examples.length !== total)
            examples.push(undefined);
        const lines = [...createMappingJs(examples)];
        if (lines.length === 1) {
            propertyMappings.push([`    ['${prop}']: ${lines[0]}`]);
        } else {
            propertyMappings.push([
                `    ['${prop}']: ${lines[0]}`,
                ...lines.slice(1, -1).map(l => `    ${l}`),
                `    ${lines[lines.length - 1]}`
            ]);
        }
    }
    yield 'mapping.object({';
    for (const mapping of propertyMappings.slice(0, -1)) {
        yield* mapping.slice(0, -1);
        yield `${mapping.slice(-1)[0]},`;
    }
    yield* propertyMappings.slice(-1)[0];
    yield '})';
}

async function toArrayAsync<T>(source: AsyncIterable<T>): Promise<T[]> {
    const result = [];
    for await (const item of source)
        result.push(item);
    return result;
}

async function* cursorToAsyncIterable<T>(cursor: r.Cursor<T>, logger: Logger, table: string): AsyncIterable<T> {
    let i = 0;
    while (true) {
        try {
            yield await cursor.next();
            if (++i % 10000 === 0)
                logger.info('Found', i, 'records in', table, '...');
        } catch (err: unknown) {
            if (err instanceof Error && err.name === 'ReqlDriverError' && err.message === 'No more rows in the cursor.')
                break;
            throw err;
        }
    }
    logger.info('Found all', i, 'records in', table);
}

//# sourceMappingURL=test.js.map
